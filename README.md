This is a partially-implemented prototype of an algorithm for procedural generation of dungeons. The goal is to place a bunch of rooms connected to each other either directly or via passages. Then we output the result as an ASCII grid. This is only a prototype; later this will be ported to Unity.

This is intended for games that use 3D models of rooms, and that have turn-based combat on a tile grid, like Rogue Trader. So we can't just draw rectangles and connect them with lines. We have a specific library of room modules, with defined dimensions and ports for doorways, and we need to link rooms to corridors or other rooms at those ports. It's also intended for systems that use modular room templates, so not all door ports need to actually have doors.

(This prototype is for the first phase of dungeon generation, where we only place "slots" for rooms and corridors. A second phase of generation then places room/corridor modules into those slots. Those modules can themselves contain slots, and so on recursively. So a room might have a slot for a room edge, which can be resolved into either a door module or a blank wall module. Parameters are passed from a slot down to the module that fills it, which then passes those parameters down to its own slots, and so on recursively.)

There are various algorithms for dungeon gen; I've tried a BSP (binary space partition) algorithm like Nethack, but I don't like the way it lays out our passages. So we're experimenting with an alternative algorithm. Relevant considerations:

- We place rooms and passages on a 2D discrete grid.
- There are various different sizes of room modules, say 12x12 or 16x8 in grid units. Each room module has "ports" allowing doors at different positions.
- Room modules can be rotated, which also moves the ports.
- Rooms are linked together either directly (port-to-port) or via passages. Passages can't overlap with rooms.
- We generally want to avoid zigzagging passages. Ideally, passages should be straight, or should meet at T-junctions or 4-way junctions. We could have passages that turn 90 degrees, but that's best avoided. We especially want to avoid passages that have multiple 90-degree joints close to each other.
- Passages can be of different widths, generally 2-8 tiles. Each room's ports can allow only some subset of passage sizes. We want to avoid "adapters" that convert passages from one width to another, since they look awkward. Let's stick with even widths for passages, so they can be centered on ports.
- We want parameters we can tune for things like the distribution of room modules, and the density of rooms in a region.
- We want the dungeon to have loops; some rooms should have 3 or more passages coming out from them. Others should be dead ends.
- All rooms should be reachable from all other rooms.
- We use a microgrid of 1x1 tiles that all rooms are compatible with. (The game is a turn-based party dungeon crawler, so combat is fought by characters moving around on this 1x1 tile grid.) Then let's use a macrogrid that's coarser, say 4x4. We align all rooms' doorways with this macrogrid. (Room's centers or top-left positions are not necessarily aligned with this macrogrid. Rooms can have dimensions that aren't multiples of 4.)
- We define a list of available room modules. These specify the size (width and height in default orientation), as well as a list of ports. For each port, we give its position, set of allowed passage widths, and direction. Let's give the position as the center of the doorway, and then increasing passage width makes the doorway grow outward in two directions from that center. Remember that modules can be rotated, changing the port locations and directions.

Here's the algorithm that we want to prototype, called the "easy links" algorithm.

* Step 1. First, we place some number of rooms randomly in our area (say 80x80 tiles), with random rotations. These have their door ports aligned with the 4x4 macrogrid. Let's ensure that the rooms are at least 1 tile apart from each other, unless they connect at at least one door port, in which case they can be directly adjacent (but not overlapping). After successfully placing a room, there's a chance that we also immediately try to place a second room directly linked to one of its ports (because this boosts the number of directly-linked rooms, which looks nice), and maybe a 3rd one. For each of these, we recursively try to place directly-linked rooms with some probability.
* Step 2. Then, we create all "easy links", defined as passages we can create that will be completely straight, directly linking to compatible ports of two rooms, and won't intersect with any other rooms in the way. Passages that intersect in 4-way junctions are fine. Pick a passage width from any of the sizes supported by both door ports.
* Step 3. Then, we look for all of the "easy" T-junctions, meaning passages we can create directly from a doorway of one room, straight to another passage, without intersecting any rooms. We choose to fill in all of these easy T-junctions, or perhaps some fraction of them. We repeat this process (including trying to make more T-junctions using corridors created in this step) until we can't make any more. We avoid linking the same room twice to the same corridor.
* Step 4. In previous steps, we kept track of which connected component every room and corridor belongs to, merging when we create direct links or corridors. Our goal is to connect more rooms so that there's only 1 component in the end. In step 4, we try to find opportunities to join these components at their doorways, using corridors bent at 90 degrees. So we pick two rooms from different components, and find unused door ports that they have. We first try to pick door ports that are as close to each other as possible on the map. Then we check if those door ports have directions at 90-degree angles from each other, and have compatible corridor width options. If they do, we compute the "bend area" - the specific tiles where we need to put a 90-degree bend. This bend area could be 2x2 (if the corridor width will be 2) or 4x4 or 6x6. Then we check that the route from each port to that bend area is clear of other rooms, and that the bend area itself is clear of other rooms. If everything checks out fine, we create the corridors and bend area, and we merge the components. We can repeat this to merge different components until we're left with 1 component, or until we don't have any remaining valid options for joining components in this way.
* Step 5. At this point, if step 4 created new corridors, we can re-run step 3 (creating T-junctions). This may merge more components.
* Step 6. If we still have multiple components, we now apply a similar 90-degree bend strategy as in step 4, but this time we try to connect door ports to existing corridors via corridors with 90-degree bends. We always connect to the closest possible spot on the corridor, so each corridor and door port specifies a unique bend area here as well.
* Step 7. If step 6 created more corridors, and we still have multiple components, we re-run step 3 (creating T-junctions), but only if it connects different components.
* Step 8. At this point, if there are still multiple components, we check the number of rooms in the largest component. If it's above a specific minimum number, then we simply delete all the smaller components, including all of their rooms and passages, and finish. If it's not above that minimum number of rooms, we reject the entire dungeon-generation run, report the error, and start trying again from the beginning, step 1.

General standards:

* Use 4 spaces for each level of indentation.
* A "door port" is a 2x1 or 1x2 rectangle if it links to a width 2 passage. This door is considered part of the room itself, and falls inside the room's rectangle. We store the door port's center position, which will have one whole-number coordinate, and one float coordinate with 0.5 fractional part. You can find the two tile coords of the door port's 1x2 or 2x1 rectangle by taking the floor or ceil of that fractional coordinate, for example (2, 4.5) means the two tiles of the door port are (2, 4) and (2, 5), measured from the top-left corner of the room. If instead that door port linked to a width-4 passage, it would also have tiles (2, 3) and (2, 6).
* We want the doors to snap to intersections on the 4x4 macrogrid, because that makes it easier to create links in step 2. For a door on north or south sides of a room, the door port is horizontal (and occupies a region of tiles that is 2 or 4 or 6 wide, and 1 tall), while doors on east or west sides of a building are vertical (so the tile region is 1 wide, and 2 or 4 or 6 tall). A horizontal door port links up to a passage running vertically, while a vertical door port links up to a passage running horizontally. To get macrogrid snapping to work, the world position of a given door must satisfy a constraint dependent on its direction. See the DOOR_MACRO_ALIGNMENT_OFFSETS.
* Note that we don't need to check all of the doors of a room against these conditions - checking one is enough, because if that one is snapped to the macrogrid, all of the others must too, because we specify our room modules to fit this condition. (TODO: add validator to check this for all defined room templates.)