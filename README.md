This is a partially-implemented prototype of an algorithm for procedural generation of dungeons. The goal is to place a bunch of rooms connected to each other either directly or via passages. Then we output the result as an ASCII grid. This is only a prototype; later this will be ported to Unity.

This is intended for games that use 3D models of rooms, and that have turn-based combat on a tile grid, like Rogue Trader. So we can't just draw rectangles and connect them with lines. We have a specific library of room modules, with defined dimensions and ports for doorways, and we need to link rooms to corridors or other rooms at those ports. It's also intended for systems that use modular room templates, so not all door ports need to actually have doors.

(This prototype is for the first phase of dungeon generation, where we only place "slots" for rooms and corridors. A second phase of generation then "resolves" those slots by placing compatible room/corridor modules into them. Those modules can themselves contain slots, and so on recursively. So a room might have a slot for a room edge, which can be resolved into either a door module or a blank wall module. Parameters are passed from a slot down to the module that fills it, which then passes those parameters down to its own slots, and so on recursively. For example a room module might hold 4 slots for its 4 walls, and each of these slots can in turn resolve to either a door, or an empty wall, or something else. The room module takes parameters indicating which of its 4 wall slots needs to have a door, then passes down the parameter to any of the 4 wall slots that needs to have a door.)

There are various algorithms for dungeon gen; I've tried a BSP (binary space partition) algorithm like Nethack, but it doesn't work very well for our use case, where we need to place 3D models that link up correctly. So we're experimenting with an alternative algorithm. Relevant considerations:

- We place rooms and passages on a 2D discrete grid.
- There are various different sizes of room modules, say 12x12 or 16x8 in grid units. Each room module has "ports" allowing doors at different positions.
- Room modules can be rotated, which also moves the ports.
- Rooms are linked together either directly (port-to-port) or via passages. Passages can't overlap with rooms.
- We generally want to avoid zigzagging passages. Ideally, passages should be straight, or should meet at T-junctions or 4-way junctions or 90-degree bends.
- Passages can be of different widths, generally 2-8 tiles. Each room's ports can allow only some subset of passage sizes. We want to avoid "adapters" that convert passages from one width to another, since they look awkward. Let's stick with even widths for passages, so they can be centered on ports.
- We want parameters we can tune for things like the distribution of room modules, and the density of rooms in a region.
- We want the dungeon to have loops; some rooms should have 3 or more passages coming out from them. Others should be dead ends.
- All rooms should be reachable from all other rooms.
- We use a microgrid of 1x1 tiles that all rooms are compatible with. (The game is a turn-based party dungeon crawler, so combat is fought by characters moving around on this 1x1 tile grid.) Then let's use a macrogrid that's coarser, say 4x4. We align all rooms' doorways with this macrogrid. (Room's centers or top-left positions are not necessarily aligned with this macrogrid. Rooms can have dimensions that aren't multiples of 4.)
- We define a list of available room modules. These specify the size (width and height in default orientation), as well as a list of ports. For each port, we give its position, set of allowed passage widths, and direction. Let's give the position as the center of the doorway, and then increasing passage width makes the doorway grow outward in two directions from that center. Remember that modules can be rotated, changing the port locations and directions.

Here's the algorithm that we want to prototype, called the "easylink" algorithm.

* Step 1. First, we place some number of rooms randomly in our area (say 80x80 tiles), with random rotations. These have their door ports aligned with the 4x4 macrogrid. After successfully placing a room, there's a chance that we also immediately try to place additional rooms directly linked to its ports (because this boosts the number of directly-linked rooms, which provides some interesting variety in layout). For each of these, we recursively try to place directly-linked rooms with some probability.
* Step 2. We define a collection of "dungeon growers". Each dungeon grower defines a strategy for adding new corridors and rooms to the dungeon, generally aiming to connect more rooms so that eventually all rooms are connected to all other rooms. Here are some dungeon growers we want; currently the first 3 are implemented:
	1. The "room-to-room" dungeon-grower identifies door ports that directly face each other, and have no other rooms in the way. It then creates a corridor directly connecting them. If this corridor crosses other existing corridors, it tries to place special rooms at the intersections, by looking through the library of room templates marked as RoomKind.FOUR_WAY to indicate they're usable here. The two crossing corridors are then split into 4 pieces linked to this 4-way intersection room.
	2. The "room-to-corridor" dungeon-grower identifies room ports directly facing an existing corridor. It then creates a corridor from the room port to the corridor, creating a special room where they meet, by looking through the library of room templates marked as RoomKind.T_JUNCTION.
	3. The "bent-room-to-room" dungeon-grower identifies room ports on different rooms that are at right-angles to each other. It then tries to place a room marked as RoomKind.BEND at a position chosen so that we can project corridors out from the two rooms that meet the bend room.
	4. (Not implemented yet.) The "corridor-to-corridor" dungeon grower identifies parallel corridors, and creates a corridor joining them, placing 2 T-junctions at the intersections.
	5. (Not implemented yet.) The "bent-room-to-corridor" dungeon-grower is similar to the room-to-corridor strategy, but aims to connect a room port to an existing corridor through a 90-degree bend. When successful, this creates both a bend room and a T-junction room.
	6. (Not implemented yet.) The "straight-corridor" dungeon-grower finds long corridors. Then it tries to create a room along the length, marked with RoomKind.THROUGH. The long corridor is split into two pieces connecting to the through-room.
	7. (Not implemented yet.) The "room-rotator" dungeon-grower finds rooms that currently have no door ports connected, and simply rotates them randomly, hoping that this allows the other dungeon-growers to connect them. It has to check that the rotated room still fits without overlapping existing rooms.
Each of these dungeon-growers takes turns operating on the dungeon, trying to incrementally add connections and rooms to the dungeon map. Each grower creates passages and rooms that can then be used by other growers to grow the map further, so we run them repeatedly. Some of them might not use all opportunities they identify, for example if it would create very small loops in the overall dungeon graph, since we don't want too many redundant passages. (This last bit is not implemented yet.)
* Step 3. In previous steps, we kept track of which connected component every room and corridor belongs to, merging when we create direct links or corridors. Our goal is to have only 1 component at the end, so that all rooms are reachable by the player's party. If there are still multiple components after the previous steps, we try deleting all components except the biggest one. Then, if the map has enough rooms, we finish. Otherwise, if the biggest component didn't have enough rooms, we reject the entire dungeon-generation run, report the error, and start trying again from step 1.

General standards:

* Use 4 spaces for each level of indentation.
* A "door port" is a 2x1 or 1x2 rectangle if it links to a width 2 passage. This door is considered part of the room itself, and falls inside the room's rectangle. We store the door port's center position, which will have one whole-number coordinate, and one float coordinate with 0.5 fractional part. You can find the two tile coords of the door port's 1x2 or 2x1 rectangle by taking the floor or ceil of that fractional coordinate, for example (2, 4.5) means the two tiles of the door port are (2, 4) and (2, 5), measured from the top-left corner of the room. If instead that door port linked to a width-4 passage, it would also have tiles (2, 3) and (2, 6).
* We want the doors to snap to intersections on the 4x4 macrogrid, because that makes it easier to create links. For a door on north or south sides of a room, the door port is horizontal (and occupies a region of tiles that is 2 or 4 or 6 wide, and 1 tall), while doors on east or west sides of a building are vertical (so the tile region is 1 wide, and 2 or 4 or 6 tall). A horizontal door port links up to a passage running vertically, while a vertical door port links up to a passage running horizontally. To get macrogrid snapping to work, the world position of a given door must satisfy a constraint dependent on its direction. See the DOOR_MACRO_ALIGNMENT_OFFSETS.
* Note that we don't need to check all of the doors of a room against these conditions - checking one is enough, because if that one is snapped to the macrogrid, all of the others must too, because we specify our room modules to fit this condition. (TODO: add validator to check this for all defined room templates.)